externalId: rca_agent
name: RMDM RCA Agent
description: "This agent is designed to retrieve different types of data from the knowledge\n  graph required for RCA and present them in Canvas. This is a repurposed / updated\n  version of the RCA agent that was created for Aker BP in the Atlas AI pilot."
instructions: "## INSTRUCTIONS\n- You are a maintenance professional and Root Cause Analysis (RCA) expert that has\n  worked in an industrial facility for 30 years.\n- Answer my questions.\n- Let me know if you need more information to answer a question.\n- When I ask you to plot time series datapoints, you only need to provide me with\n  the graph. Not the dataframe of the values.\n- Be proactive and ask follow-up questions.\n- Guide the user through the RCA workflow.\n- When you have retrieved time series for an asset, always ask the user if they also\n  want to see time series for children, siblings, or the parent asset(s) as well.\n- DO NOT create a cause map, even if asked to. Instead, tell the user to switch to\n  the \"Cause Map Agent.\"\n\n## GOAL\nYou are going to help the user conduct a Root Cause Analysis (RCA) on a failing\n  piece of equipment or asset. You are not to make assumptions or hallucinate, you\n  are only going to answer questions, present objective information and ask proactive\n  follow-up questions to guide the user through an RCA workflow within the industrial\n  domain.\n\n## ADDITIONAL CONTEXT\nThe data the user is interest in exists in an industrial knowledge graph. You have\n  been equipped with the necessary tools to fetch data from the graph and interact\n  with it, but it is helpful to have a surface level understanding of how the data\n  is structured.\n\nThe data types you will typically be asked to find are:\n- Maintenance orders / work orders\n- Notifications and failure notifications\n- Files / documents\n- Time series (both metadata and datapoints)\n- Images\n\nAll of the data types above are typically related to an asset (also called \"tag\"\n  or \"FLOC\") which exists as part of an asset hierarchy within the industrial knowledge\n  graph. That means a given asset will typically have a parent and multiple children\n  assets, also called sub-assets.\n\n### RCA WORKFLOW\nA typical RCA workflow will generally follow these steps:\n1. Find an asset.\n2. Find related files / documents.\n3. Find related time series. Ideally the time series are directly related to the\n  asset of interest, but may in some cases be related to children, siblings, or the\n  parent of the asset as well.\n4. Find and analyze related maintenance orders. Typically, the user will be interested\n  in \"corrective\" maintenance orders.\n5. Find  and analyze related notifications. Typically, the user will be interested\n  in \"failure\" notifications.\"\n6. Find most common failures.\n7. Generate cause map, otherwise known as hypothesis tree"
model: azure/gpt-4o
labels:
- published
tools:
- name: Find Failure notifications
  description: Use this tool to get information about failure notifications.
  type: queryKnowledgeGraph
  configuration:
    dataModels:
    - space: rmdm
      externalId: rmdm
      version: v1
      viewExternalIds:
      - FailureNotification
    instanceSpaces:
      type: all
- name: Find time series
  description: Use this tool to get information about time series.
  type: queryKnowledgeGraph
  configuration:
    dataModels:
    - space: rmdm
      externalId: rmdm
      version: v1
      viewExternalIds:
      - Timeseries_ext
    instanceSpaces:
      type: all
- name: Answer document questions
  description: "Documents Question Answering. This function is used to get the answer\n    to a question from a document, perform semantic search on the documents."
  type: askDocument
- name: Query and analyze images
  description: "This tool is used to analyze images. Only use this tool if the\n  goal of the query is to analyze/describe/query the visual contents of an\n  image. Supported mime types are (image/jpeg,image/png,image/svg+xml,image/webp)"
  type: analyzeImage
- name: Find related documents
  description: "when you find related documents, please return ALL the documents, grouped\n    by the file category header"
  type: runPythonCode
  configuration:
    schema:
      type: object
      properties:
        asset_external_id:
          type: string
          default: "''"
      required: []
    pythonCode: "import time\nfrom cognite.client import CogniteClient\nfrom cognite.client.data_classes.data_modeling import ViewId\nfrom typing import List, Dict\nclient = CogniteClient()\n\ndef construct_filter(fltr, filter_=\"equals\"):\n    if not fltr:\n        return None\n    # Constructing filter based on the provided filter structure\n    # Example: [{\"property\": \"Facility\", \"value\": \"ASGARD\"}] hello\n    \n    constructed_filter = {\"and\": []}\n    \n    for condition in fltr:\n        property_name = condition.get(\"property\")\n        value = condition.get(\"value\")\n        \n        filter_value = \"value\" if filter_== \"equals\" else \"values\"\n        \n        if property_name and value:\n            constructed_filter[\"and\"].append({\n                filter_: {\n                    \"property\": [property_name],\n                    filter_value: value\n                }\n            })\n    \n    return constructed_filter\n\ndef dump_results(res):\n    toPush = []\n    for res_elem in res:\n        dump = res_elem.dump()\n        space = dump[\"space\"]\n        datamodel_space = list(dump[\"properties\"].keys())[0]\n        dm_ = list(dump[\"properties\"][datamodel_space].keys())[0]\n        \n        mydict = dump[\"properties\"][datamodel_space][dm_]\n        #filtered_properties = {k: mydict[k] for k in ['name', 'description'] if k in mydict }\n        filtered_properties = {k: mydict[k] for k in mydict.keys() if type(mydict[k]) != type([]) }\n\n        filtered_main_properties = {k: dump[k] for k in ['externalId', 'space'] if k in dump }\n        \n        view = {\n            \"viewExternalId\": dm_.split(\"/\")[0],\n            \"viewSpace\":datamodel_space,\n            \"viewVersion\":dm_.split(\"/\")[1]\n        }\n        final_dump =  {**view, **filtered_main_properties, **filtered_properties}\n        toPush.append(final_dump)\n    return toPush\n\ndef handle(asset_external_id:str=\"\") -> Dict:\n    space = \"rmdm\"\n    VIEW_EXTERNAL_ID=\"Asset\"\n    \n    #query: str = data.get(\"query\", \"suct\")\n    #limit: int = data.get(\"limit\", 60)\n    view =  {\"space\":space, \"externalId\": VIEW_EXTERNAL_ID, \"version\":\"v1\"}\n    external_id = asset_external_id\n    # data.get(\"asset_external_id\", \"\")\n    \n    t1_list = time.time()\n    \n    categories = [\"DS_FILECAT_NORSOK\", \"MB_FILECAT_NORSOK\", \"XB_FILECAT_NORSOK\"]\n\n    cognite_filter = construct_filter([{\"property\": \"mimeType\", \"value\":[\"application/pdf\"] },\n        {\"property\": \"assets\", \"value\":[{'space': 'rmdm', 'externalId': external_id}]}\n    ,{\"property\": \"category\", \"value\": [{'space': 'rmdm', 'externalId': cat} for cat in categories]}], filter_=\"containsAny\")\n    \n    files = client.data_modeling.instances.search(\n        limit=60,\n        query=\"\", # suct and ..\n        properties=[\n            \"name\",\n            \"description\",\n        ],\n        filter=cognite_filter,\n        view=ViewId(view[\"space\"], \"File_ext\", view[\"version\"])\n    )\n\n    t2_list = time.time()\n    print(\"Search instances time:\", t2_list - t1_list, \"seconds\")\n    \n    print(\"Num instances\", len(files))\n    \n\n    return {\"total_count\":len(files), \"instances\": dump_results(files)}\n    "
- name: Find images
  description: Use this tool to get information about images.
  type: runPythonCode
  configuration:
    schema:
      type: object
      properties:
        asset_external_id:
          type: string
      required:
      - asset_external_id
    pythonCode: "import time\nfrom cognite.client import CogniteClient\nfrom cognite.client.data_classes.data_modeling import ViewId\nfrom typing import List, Dict\nclient = CogniteClient()\n\ndef construct_filter(fltr, filter_=\"equals\"):\n    if not fltr:\n        return None\n    # Constructing filter based on the provided filter structure\n    # Example: [{\"property\": \"Facility\", \"value\": \"ASGARD\"}] hello\n    \n    constructed_filter = {\"and\": []}\n    \n    for condition in fltr:\n        property_name = condition.get(\"property\")\n        value = condition.get(\"value\")\n        \n        filter_value = \"value\" if filter_== \"equals\" else \"values\"\n        \n        if property_name and value:\n            constructed_filter[\"and\"].append({\n                filter_: {\n                    \"property\": [property_name],\n                    filter_value: value\n                }\n            })\n    \n    return constructed_filter\n\ndef dump_results(res):\n    toPush = []\n    for res_elem in res:\n        dump = res_elem.dump()\n        space = dump[\"space\"]\n        datamodel_space = list(dump[\"properties\"].keys())[0]\n        dm_ = list(dump[\"properties\"][datamodel_space].keys())[0]\n        \n        mydict = dump[\"properties\"][datamodel_space][dm_]\n        #filtered_properties = {k: mydict[k] for k in ['name', 'description'] if k in mydict }\n        filtered_properties = {k: mydict[k] for k in mydict.keys() if type(mydict[k]) != type([]) }\n\n        filtered_main_properties = {k: dump[k] for k in ['externalId', 'space'] if k in dump }\n        \n        view = {\n            \"viewExternalId\": dm_.split(\"/\")[0],\n            \"viewSpace\":datamodel_space,\n            \"viewVersion\":dm_.split(\"/\")[1]\n        }\n        final_dump =  {**view, **filtered_main_properties, **filtered_properties}\n        toPush.append(final_dump)\n    return toPush\n\ndef handle(asset_external_id:str) -> Dict:\n    space = \"rmdm\"\n    VIEW_EXTERNAL_ID=\"File_ext\"\n    mimeType=\"image/jpeg\"\n    \n    view =  {\"space\":space, \"externalId\": VIEW_EXTERNAL_ID, \"version\":\"v1\"}\n    external_id = asset_external_id\n    \n    t1_list = time.time()\n    cognite_filter = construct_filter([{\"property\": \"mimeType\", \"value\":mimeType },\n        {\"property\": \"assets\", \"value\":{'space': 'rmdm', 'externalId': external_id}}])\n    \n    files = client.data_modeling.instances.search(\n        limit=60,\n        query=\"\",\n        properties=[\n            \"name\",\n            \"description\",\n        ],\n        filter=cognite_filter,\n        view=ViewId(view[\"space\"], \"File_ext\", view[\"version\"])\n    )\n\n    t2_list = time.time()\n    print(\"Search instances time:\", t2_list - t1_list, \"seconds\")\n    \n    print(\"Num instances\", len(files))\n    \n    return {\"total_count\":len(files),\"instances\": dump_results(files)}\n"
- name: Find time series for related assets
  description: "Use this tool when you need to find time series related to the children,\n    siblings or parent of an asset."
  type: runPythonCode
  configuration:
    schema:
      type: object
      properties:
        which:
          type: string
          default: "'siblings'"
          description: "Which related assets to include. Can be \"parent\", \"siblings\", \"children\",\n            or \"all\". Defaults to \"siblings\"."
        asset_external_id:
          type: string
          description: The external ID of the asset for which to find related assets
            and timeseries.
      required:
      - asset_external_id
    pythonCode: "from cognite.client.data_classes.filters import And, In, ContainsAny, Equals, Not\nfrom cognite.client.data_classes.data_modeling import ViewId, NodeList\nfrom cognite.client.data_classes.data_modeling.query import Query, Select, NodeResultSetExpression, SourceSelector, QueryResult, NodeListWithCursor\nfrom cognite.client import CogniteClient\n\nclient = CogniteClient()\nasset_view = client.data_modeling.views.retrieve(\n    ViewId(space=\"rmdm\", external_id=\"Asset\", version=\"v1\")\n)[0]\nasset_view_id = asset_view.as_id()\n\ndef construct_query(asset_external_id: str) -> Query:\n    return Query(\n        with_ = {\n            \"starting_asset\": NodeResultSetExpression(\n                filter = And(\n                    Equals([\"node\", \"externalId\"], value=asset_external_id),\n                    Equals([\"node\", \"space\"], value={\"parameter\": \"instance_space\"})\n                )\n            ),\n            \"children\": NodeResultSetExpression(\n                from_ = \"starting_asset\",\n                through=asset_view.as_property_ref(\"parent\"),\n                direction=\"inwards\",\n            ),\n            \"parent_asset\": NodeResultSetExpression(\n                from_ = \"starting_asset\",\n                through=asset_view.as_property_ref(\"parent\"),\n                direction=\"outwards\"\n            ),\n            \"siblings\": NodeResultSetExpression(\n                from_ = \"parent_asset\",\n                through=asset_view.as_property_ref(\"parent\"),\n                direction=\"inwards\",\n                filter=Not(Equals(property=[\"node\", \"externalId\"], value=asset_external_id))\n            ),\n        },\n        select = {\n            \"starting_asset\": Select(\n                [SourceSelector(asset_view_id, [\"*\"])]\n            ),\n            \"children\": Select(\n                [SourceSelector(asset_view_id, [\"*\"])]\n            ),\n            \"parent_asset\": Select(\n                [SourceSelector(asset_view_id, [\"*\"])]\n            ),\n            \"siblings\": Select(\n                [SourceSelector(asset_view_id, [\"*\"])]\n            ),\n        },\n        parameters = {\n            \"instance_space\": \"rmdm\"\n        }\n    )\n\ndef fetch_nearby_assets(client: CogniteClient, asset_external_id: str) -> QueryResult:\n    query = construct_query(asset_external_id)\n    result = client.data_modeling.instances.query(query)\n    return result\n\ndef get_related_timeseries(assets: NodeListWithCursor, query : str = \"\") -> NodeList:\n    timeseries = client.data_modeling.instances.search(\n        limit=None,\n        query=query,\n        properties=[\n            \"name\",\n            \"description\"\n        ],\n        filter=ContainsAny(\n            property=[\"cdf_cdm\", \"CogniteTimeSeries/v1\", \"assets\"],\n            values=[{\"space\":\"rmdm\",\"externalId\":asset.external_id} for asset in assets]\n        ),\n        view=ViewId(\"cdf_cdm\", \"CogniteTimeSeries\", \"v1\")\n    )\n    return timeseries\n\ndef dump_results(res):\n    toPush = []\n    for res_elem in res:\n        dump = res_elem.dump()\n        space = dump[\"space\"]\n        datamodel_space = list(dump[\"properties\"].keys())[0]\n        dm_ = list(dump[\"properties\"][datamodel_space].keys())[0]\n        \n        mydict = dump[\"properties\"][datamodel_space][dm_]\n        filtered_properties = {k: mydict[k] for k in mydict.keys() if type(mydict[k]) != type([]) }\n\n        filtered_main_properties = {k: dump[k] for k in ['externalId', 'space'] if k in dump }\n        \n        view = {\n            \"viewExternalId\": dm_.split(\"/\")[0],\n            \"viewSpace\":datamodel_space,\n            \"viewVersion\":dm_.split(\"/\")[1]\n        }\n        final_dump =  {**view, **filtered_main_properties, **filtered_properties}\n        toPush.append(final_dump)\n    return toPush\n\ndef handle(asset_external_id: str, which: str = \"siblings\") -> dict:\n    \"\"\"\n    Retrieve timeseries for parent, children and sibling assets related to a given asset in the industrial knowledge graph.\n\n    Args:\n        asset_external_id (str): The external ID of the asset for which to find related assets and timeseries.\n        which (str): Which related assets to include. Can be \"parent\", \"siblings\", \"children\", or \"all\". Defaults to \"siblings\".\n\n    Returns:\n        Dict: A dictionary containing the timeseries data for the related assets, or a message if no assets are found.\n    \"\"\"\n\n    allowed = [\"parent\", \"siblings\", \"children\", \"all\"]\n    if which not in allowed:\n        raise ValueError(f\"'which' must be one of {allowed}, got '{which}'\")\n    \n    nearby_assets = fetch_nearby_assets(client, asset_external_id)\n    if not nearby_assets:\n        return \"No assets found for the given external ID.\"\n\n    if which == \"all\":\n        keys_list = list(nearby_assets.keys())\n        assets = NodeList([])\n        for key in keys_list:\n            assets.extend(nearby_assets.get(key, []))\n    elif which == \"parent\":\n        assets = nearby_assets.get(\"parent_asset\", [])\n    elif which == \"children\":\n        assets = nearby_assets.get(\"children\", [])\n    elif which == \"siblings\":\n        assets = nearby_assets.get(\"siblings\", [])\n\n    timeseries = get_related_timeseries(assets)\n    \n    return {\"total_count\":len(timeseries), \"items\": dump_results(timeseries)}"
- name: "Find maintenance orders "
  description: "Use this tool to get information about maintenance orders, often called\n    work orders.\nWhen I ask for Corrective maintenance orders, filter query based on for PM02 type\nWhen I ask for Preventive maintenance Orders, filter query based on for PM03 type"
  type: runPythonCode
  configuration:
    schema:
      type: object
      properties:
        filter_type:
          type: string
          default: "'PM02'"
        asset_external_id:
          type: string
          default: "''"
      required: []
    pythonCode: "import time\nfrom cognite.client import CogniteClient\nfrom cognite.client.data_classes.data_modeling import ViewId\nfrom typing import List, Dict\n\n# Initialize the Cognite client (ensure it is configured with your credentials)\nclient = CogniteClient()\n\ndef construct_filter(fltr, filter_=\"equals\"):\n    if not fltr:\n        return None\n    \n    constructed_filter = {\"and\": []}\n    \n    for condition in fltr:\n        property_name = condition.get(\"property\")\n        value = condition.get(\"value\")\n        \n        filter_value = \"value\" if filter_== \"equals\" else \"values\"\n        \n        if property_name and value:\n            constructed_filter[\"and\"].append({\n                filter_: {\n                    \"property\": [property_name],\n                    filter_value: value\n                }\n            })\n    \n    return constructed_filter\n\ndef dump_results(res):\n    toPush = []\n    for res_elem in res:\n        dump = res_elem.dump()\n        space = dump[\"space\"]\n        datamodel_space = list(dump[\"properties\"].keys())[0]\n        dm_ = list(dump[\"properties\"][datamodel_space].keys())[0]\n        \n        mydict = dump[\"properties\"][datamodel_space][dm_]\n        #filtered_properties = {k: mydict[k] for k in ['name', 'description'] if k in mydict }\n        filtered_properties = {k: mydict[k] for k in mydict.keys() if type(mydict[k]) != type([]) }\n\n        filtered_main_properties = {k: dump[k] for k in ['externalId', 'space'] if k in dump }\n        \n        view = {\n            \"viewExternalId\": dm_.split(\"/\")[0],\n            \"viewSpace\":datamodel_space,\n            \"viewVersion\":dm_.split(\"/\")[1]\n        }\n        final_dump =  {**view, **filtered_main_properties, **filtered_properties}\n        toPush.append(final_dump)\n    return toPush\n\ndef handle(asset_external_id:str=\"\", filter_type:str=\"PM02\") -> Dict:\n    space = \"rmdm\"\n    VIEW_EXTERNAL_ID=\"Asset\"\n    view_version = \"v1\"\n    \n    #query: str = data.get(\"query\", \"\")\n    view: Dict[str, str] =  {\"space\":space, \"externalId\": VIEW_EXTERNAL_ID, \"version\":view_version}\n    external_id =asset_external_id\n    # PM02 ==  Corrective maintenance orders\n    # PM03 == Preventive maintenance Orders\n    filterType = filter_type\n      #data.get(\"filter_type\", \"PM02\")\n    \n    t1_list = time.time()\n\n    # Perform the search with the constructed filter\n    cognite_filter = construct_filter([{\"property\": \"parent\", \"value\": {'space': 'rmdm', 'externalId': external_id}}])\n    children = client.data_modeling.instances.search(\n        limit=200,\n        query=\"\",\n        properties=[\n            \"name\",\n            \"description\",\n        ],\n        filter=cognite_filter,\n        view=ViewId(view[\"space\"], \"Asset\", view[\"version\"])\n    )\n    # for now we dont search the childs.\n    external_ids = [external_id] #+ [c.external_id for c in children]\n\n    \n    cognite_filter = construct_filter([\n        {\"property\": \"assets\", \"value\":[{'space': 'rmdm', 'externalId': ext} for ext in external_ids]}\n    ,{\"property\": \"type\", \"value\": [filterType]}], filter_=\"containsAny\")\n    \n    files = client.data_modeling.instances.search(\n        limit=60,\n        query=\"\", \n        properties=[\n            \"name\",\n            \"description\",\n        ],\n        filter=cognite_filter,\n        view=ViewId(view[\"space\"], \"MaintenanceOrder\",view_version)\n    )\n\n    t2_list = time.time()\n    print(\"Search instances time:\", t2_list - t1_list, \"seconds\")\n    \n    print(\"Num instances\", len(files))\n   \n    \n    return {\"total_count\":len(files) , \"instances\": dump_results(files)}\n    "
- name: Find Assets
  description: "Use this tool to get information about assets.\nWhen describing the Asset,\n  use only Name and the Description.\nRemove Tags and Aliases"
  type: queryKnowledgeGraph
  configuration:
    dataModels:
    - space: rmdm
      externalId: rmdm
      version: v1
      viewExternalIds:
      - Asset
    instanceSpaces:
      type: all
